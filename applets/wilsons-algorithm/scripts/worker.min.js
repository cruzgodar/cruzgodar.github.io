"use strict";let gridSize,maximumSpeed,noBorders,reverseGenerateSkeleton,numSkeletonLines=0,edgesInTree=[],verticesNotInTree=[];const verticesInTree=[],grid=[];let newVertices=[],currentRow,currentColumn,currentRowBaseCamp,currentColumnBaseCamp,randomWalkFromEndpointAttmepts=0,randomWalk=wasmRandomWalk,numShortPathsInARow=0,percentStep=1;async function drawWilsonGraph(){edgesInTree=[],verticesNotInTree=[];for(let r=0;r<gridSize;r++)for(let e=0;e<gridSize;e++)verticesNotInTree[gridSize*r+e]=[r,e],grid[gridSize*r+e]=0;for(;0<verticesNotInTree.length;)maximumSpeed?wilsonStep():await wilsonStep(),verticesInTree.length>=gridSize*gridSize/100*percentStep&&(postMessage(["progress",percentStep]),percentStep++)}async function wilsonStep(){if(newVertices=[],reverseGenerateSkeleton){if(0===verticesInTree.length&&(currentRow=Math.floor(Math.random()*gridSize/5+2*gridSize/5),currentColumn=Math.floor(Math.random()*gridSize/5+2*gridSize/5)),jsRandomWalk(100),newVertices.splice(newVertices.length-1,1),newVertices.length<99)return void(randomWalkFromEndpointAttmepts<100?(randomWalkFromEndpointAttmepts++,currentRow=currentRowBaseCamp,currentColumn=currentColumnBaseCamp):0!==verticesInTree.length&&100===randomWalkFromEndpointAttmepts&&(randomWalkFromEndpointAttmepts=0,e=Math.floor(Math.random()*verticesInTree.length),currentRow=verticesInTree[e][0],currentColumn=verticesInTree[e][1]));randomWalkFromEndpointAttmepts=0,currentRowBaseCamp=newVertices[newVertices.length-2][0],currentColumnBaseCamp=newVertices[newVertices.length-2][1],currentRow=currentRowBaseCamp,currentColumn=currentColumnBaseCamp,++numSkeletonLines===Math.floor(gridSize/5)&&(reverseGenerateSkeleton=!1,postMessage(["log","Going back to regular LERWs"]))}else{var e=Math.floor(Math.random()*verticesNotInTree.length);if(currentRow=verticesNotInTree[e][0],currentColumn=verticesNotInTree[e][1],0===edgesInTree.length){let e=5*gridSize;gridSize<=100?e=gridSize:gridSize<=300&&(e=3*gridSize),randomWalk(e),postMessage(["log","Got it in time!"])}else randomWalk()}for(let n=0;n<newVertices.length-1;n++)maximumSpeed?drawLine(newVertices[n][0],newVertices[n][1],newVertices[n+1][0],newVertices[n+1][1],"rgb(255, 255, 255)",0):await drawLine(newVertices[n][0],newVertices[n][1],newVertices[n+1][0],newVertices[n+1][1],"rgb(255, 255, 255)",300/gridSize);for(let t=0;t<newVertices.length;t++){grid[gridSize*newVertices[t][0]+newVertices[t][1]]=1;var r=vertexInArray(newVertices[t],verticesNotInTree);-1!==r&&(verticesNotInTree.splice(r,1),verticesInTree.push(newVertices[t])),t!==newVertices.length-1&&edgesInTree.push([newVertices[t],newVertices[t+1]])}}function wasmRandomWalk(fixedLength=0){var e=ccallArrays("random_walk","number",["number","array","number","number","number"],[gridSize,grid,fixedLength,currentRow,currentColumn],{heapIn:"HEAPU32"}),r=Module.HEAPU32[e/Uint32Array.BYTES_PER_ELEMENT];for(let n=2;n<2*r;n+=2)newVertices.push([Module.HEAPU32[e/Uint32Array.BYTES_PER_ELEMENT+n],Module.HEAPU32[e/Uint32Array.BYTES_PER_ELEMENT+n+1]]);Module.ccall("free_from_js",null,["number"],[e]),!1===reverseGenerateSkeleton&&r<gridSize/10?10==++numShortPathsInARow&&(randomWalk=jsRandomWalk,postMessage(["log","Switching to JS..."])):numShortPathsInARow=0}function jsRandomWalk(fixedLength=0){for(newVertices=[[currentRow,currentColumn]];;){let e=[];var r=(e=0===currentRow&&0===currentColumn?[1,2]:currentRow===gridSize-1&&0===currentColumn?[0,1]:0===currentRow&&currentColumn===gridSize-1?[2,3]:currentRow===gridSize-1&&currentColumn===gridSize-1?[0,3]:0===currentRow?[1,2,3]:currentRow===gridSize-1?[0,1,3]:0===currentColumn?[0,1,2]:currentColumn===gridSize-1?[0,2,3]:[0,1,2,3])[Math.floor(Math.random()*e.length)],r=(0===r?currentRow--:1===r?currentColumn++:2===r?currentRow++:currentColumn--,vertexInArray([currentRow,currentColumn],newVertices));if(-1!==r?(currentRow=newVertices[r][0],currentColumn=newVertices[r][1],newVertices=newVertices.slice(0,r+1)):newVertices.push([currentRow,currentColumn]),1===grid[gridSize*currentRow+currentColumn])break;if(0!==fixedLength&&newVertices.length===fixedLength)break}}async function colorGraph(linearColoring=!1){var r=[];for(let S=0;S<gridSize;S++){r[S]=[];for(let e=0;e<gridSize;e++)r[S][e]=[]}for(let f=0;f<edgesInTree.length;f++){var e=edgesInTree[f][0][0],n=edgesInTree[f][0][1],t=edgesInTree[f][1][0],o=edgesInTree[f][1][1];e===t?(r[e][Math.min(n,o)].includes(1)||r[e][Math.min(n,o)].push(1),r[t][Math.max(n,o)].includes(3)||r[t][Math.max(n,o)].push(3)):(r[Math.min(e,t)][n].includes(2)||r[Math.min(e,t)][n].push(2),r[Math.max(e,t)][n].includes(0)||r[Math.max(e,t)][o].push(0))}var i=[];let a=[];a=gridSize%2==1?[[Math.floor(gridSize/2),Math.floor(gridSize/2),0]]:[[Math.floor(gridSize/2)-1,Math.floor(gridSize/2)-1,0],[Math.floor(gridSize/2)-1,Math.floor(gridSize/2),0],[Math.floor(gridSize/2),Math.floor(gridSize/2)-1,0],[Math.floor(gridSize/2),Math.floor(gridSize/2),0]];var s=[];for(let M=0;M<gridSize;M++){s[M]=[];for(let e=0;e<gridSize;e++)s[M][e]=-1}for(;0<a.length;){var l=a.length;for(let e=0;e<l;e++){var c=a[e][0],u=a[e][1],d=a[e][2];s[c][u]=d,r[c][u].includes(0)&&-1===s[c-1][u]&&(a.push([c-1,u,d+1]),i.push([[c,u],[c-1,u],d])),r[c][u].includes(1)&&-1===s[c][u+1]&&(a.push([c,u+1,d+1]),i.push([[c,u],[c,u+1],d])),r[c][u].includes(2)&&-1===s[c+1][u]&&(a.push([c+1,u,d+1]),i.push([[c,u],[c+1,u],d])),r[c][u].includes(3)&&-1===s[c][u-1]&&(a.push([c,u-1,d+1]),i.push([[c,u],[c,u-1],d]))}a.splice(0,l)}i.sort((a,b)=>a[2]-b[2]);var m=7*i[i.length-1][2]/6,g=[0];let h=0;for(let v=0;v<i.length;v++)i[v][2]>h&&(g.push(v),h++);g.push(i.length);for(let z=0;z<g.length;z++){let e=0;var w=Math.min(g[z],i.length-1),p=HSVtoRGB(linearColoring?i[w][2]/m:g[z+1]/i.length*6/7,1,1);for(e=g[z];e<g[z+1]-1;e++)drawLine(i[e][0][0],i[e][0][1],i[e][1][0],i[e][1][1],`rgb(${p[0]}, ${p[1]}, ${p[2]})`,0);i[e]&&(maximumSpeed?drawLine(i[e][0][0],i[e][0][1],i[e][1][0],i[e][1][1],`rgb(${p[0]}, ${p[1]}, ${p[2]})`,24):await drawLine(i[e][0][0],i[e][0][1],i[e][1][0],i[e][1][1],`rgb(${p[0]}, ${p[1]}, ${p[2]})`,24))}}async function drawLine(row1,column1,row2,column2,color,delay){var e,r;column1===column2?(e=column1,r=Math.min(row1,row2),noBorders?postMessage([e,r,1,2,color]):postMessage([2*e+1,2*r+1,1,3,color])):(e=Math.min(column1,column2),r=row1,noBorders?postMessage([e,r,2,1,color]):postMessage([2*e+1,2*r+1,3,1,color])),await new Promise(resolve=>setTimeout(resolve,delay))}function vertexInArray(element,array){for(let e=0;e<array.length;e++)if(array[e][0]===element[0]&&array[e][1]===element[1])return e;return-1}function HSVtoRGB(h,s,v){let e,r,n;var t=Math.floor(6*h),o=6*h-t,i=v*(1-s),a=v*(1-o*s),l=v*(1-(1-o)*s);switch(t%6){case 0:e=v,r=l,n=i;break;case 1:e=a,r=v,n=i;break;case 2:e=i,r=v,n=l;break;case 3:e=i,r=a,n=v;break;case 4:e=l,r=i,n=v;break;case 5:e=v,r=i,n=a}return[Math.round(255*e),Math.round(255*r),Math.round(255*n)]}onmessage=async function(e){gridSize=e.data[0],maximumSpeed=e.data[1],noBorders=e.data[2],reverseGenerateSkeleton=e.data[3],importScripts("/applets/wilsons-algorithm/scripts/random-walk.js"),Module.onRuntimeInitialized=async function(){importScripts("/scripts/wasm-arrays.min.js"),await drawWilsonGraph(),await colorGraph(),postMessage(["done"])}};