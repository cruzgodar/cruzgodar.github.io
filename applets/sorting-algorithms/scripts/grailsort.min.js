const Subarray={LEFT:1,RIGHT:2};class GrailComparator{constructor(){}compare(leftPair,rightPair){return console.log(leftPair,rightPair),leftPair<rightPair?-1:rightPair<leftPair?1:0}}class GrailSort{static GRAIL_STATIC_EXT_BUF_LEN=512;constructor(readFromPosition,writeToPosition){this.readFromPosition=readFromPosition,this.writeToPosition=writeToPosition,this.grailComp=new GrailComparator,this.externalBuffer,this.externalBufferLen,this.currentBlockLen,this.currentBlockOrigin}*grailSwap(array,a,b){var r=array[a];array[a]=array[b],array[b]=r,this.writeToPosition(a)&&(yield),this.writeToPosition(b)&&(yield)}*grailBlockSwap(array,a,b,blockLen){for(let r=0;r<blockLen;r++)yield*this.grailSwap(array,a+r,b+r)}*arraycopy(srcArray,srcPos,destArray,destPos,copyLen){if(srcArray===destArray){for(let r=destPos;r<destPos+copyLen;r++)this.writeToPosition(r)&&(yield);srcArray.copyWithin(destPos,srcPos,srcPos+copyLen)}else if(0===srcPos&&copyLen===srcArray.length)srcArray.slice();else for(let r=0;r<copyLen;r++)this.writeToPosition(destPos+r)&&(yield),destArray[destPos+r]=srcArray[srcPos+r]}grailRotate(array,start,leftLen,rightLen){for(;0<leftLen&&0<rightLen;)leftLen<=rightLen?(this.grailBlockSwap(array,start,start+leftLen,leftLen),start+=leftLen,rightLen-=leftLen):(this.grailBlockSwap(array,start+leftLen-rightLen,start+leftLen,rightLen),leftLen-=rightLen)}*grailInsertSort(array,start,length){for(let t=1;t<length;t++){let r=start+t-1,a=start+t;for(this.readFromPosition(r),this.readFromPosition(a);r>=start&&0<this.grailComp.compare(array[r],array[a]);)yield*this.grailSwap(array,r,a),r--,a--}}grailBinarySearchLeft(array,start,length,target){let r=0,a=length;for(;r<a;){var t=r+parseInt((a-r)/2);this.grailComp.compare(array[start+t],target)<0?r=t+1:a=t}return r}grailBinarySearchRight(array,start,length,target){let r=0,a=length;for(;r<a;){var t=r+parseInt((a-r)/2);0<this.grailComp.compare(array[start+t],target)?a=t:r=t+1}return a}grailCollectKeys(array,start,length,idealKeys){let r=1,a=0,t=1;for(;t<length&&r<idealKeys;){var e=this.grailBinarySearchLeft(array,start+a,r,array[start+t]);e!=r&&0==this.grailComp.compare(array[start+t],array[start+a+e])||(this.grailRotate(array,start+a,r,t-(a+r)),a=t-r,this.grailRotate(array,start+a+e,r-e,1),r++),t++}return this.grailRotate(array,start,a,r),r}grailPairwiseSwaps(array,start,length){let r;for(r=1;r<length;r+=2){const t=start+r-1;var a=start+r;0<this.grailComp.compare(array[t],array[a])?(this.grailSwap(array,t-2,a),this.grailSwap(array,a-2,t)):(this.grailSwap(array,t-2,t),this.grailSwap(array,a-2,a))}const t=start+r-1;t<start+length&&this.grailSwap(array,t-2,t)}grailPairwiseWrites(array,start,length){let r;for(r=1;r<length;r+=2){const t=start+r-1;var a=start+r;0<this.grailComp.compare(array[t],array[a])?(array[t-2]=array[a],array[a-2]=array[t]):(array[t-2]=array[t],array[a-2]=array[a])}const t=start+r-1;t<start+length&&(array[t-2]=array[t])}grailMergeForwards(array,start,leftLen,rightLen,bufferOffset){let r=start;var a=start+leftLen;let t=a;var e=a+rightLen;let l=start-bufferOffset;for(;t<e;)r==a||0<this.grailComp.compare(array[r],array[t])?(this.grailSwap(array,l,t),t++):(this.grailSwap(array,l,r),r++),l++;l!=r&&this.grailBlockSwap(array,l,r,a-r)}grailMergeBackwards(array,start,leftLen,rightLen,bufferOffset){let r=start+leftLen-1;var a=r;let t=a+rightLen;var e=start;let l=t+bufferOffset;for(;r>=e;)t==a||0<this.grailComp.compare(array[r],array[t])?(this.grailSwap(array,l,r),r--):(this.grailSwap(array,l,t),t--),l--;if(t!=l)for(;t>a;)this.grailSwap(array,l,t),l--,t--}grailMergeOutOfPlace(array,start,leftLen,rightLen,bufferOffset){let r=start;var a=start+leftLen;let t=a;var e=a+rightLen;let l=start-bufferOffset;for(;t<e;)r==a||0<this.grailComp.compare(array[r],array[t])?(array[l]=array[t],t++):(array[l]=array[r],r++),l++;if(l!=r)for(;r<a;)array[l]=array[r],l++,r++}grailBuildInPlace(array,start,length,currentMerge,bufferLen){for(let i=currentMerge;i<bufferLen;i*=2){let r;var a=start+length-2*i,t=i;for(r=start;r<=a;r+=2*i)this.grailMergeForwards(array,r,i,i,t);var e=length-(r-start);e>i?this.grailMergeForwards(array,r,i,e-i,t):this.grailRotate(array,r-i,i,e),start-=i}var r=length%(2*bufferLen),l=start+length-r;r<=bufferLen?this.grailRotate(array,l,r,bufferLen):this.grailMergeBackwards(array,l,bufferLen,r-bufferLen,bufferLen);for(let s=l-2*bufferLen;s>=start;s-=2*bufferLen)this.grailMergeBackwards(array,s,bufferLen,bufferLen,bufferLen)}grailBuildOutOfPlace(array,start,length,bufferLen,externLen){this.arraycopy(array,start-externLen,this.externalBuffer,0,externLen),this.grailPairwiseWrites(array,start,length),start-=2;let t;for(t=2;t<externLen;t*=2){let a;var r=start+length-2*t,e=t;for(a=start;a<=r;a+=2*t)this.grailMergeOutOfPlace(array,a,t,t,e);var l=length-(a-start);if(l>t)this.grailMergeOutOfPlace(array,a,t,l-t,e);else for(let r=0;r<l;r++)array[a+r-t]=array[a+r];start-=t}this.arraycopy(this.externalBuffer,0,array,start+length,externLen),this.grailBuildInPlace(array,start,length,t,bufferLen)}grailBuildBlocks(array,start,length,bufferLen){if(null!=this.externalBuffer){let r;if(bufferLen<this.externalBufferLen)r=bufferLen;else for(r=1;2*r<=this.externalBufferLen;)r*=2;this.grailBuildOutOfPlace(array,start,length,bufferLen,r)}else this.grailPairwiseSwaps(array,start,length),this.grailBuildInPlace(array,start-2,length,2,bufferLen)}grailBlockSelectSort(array,keys,start,medianKey,blockCount,blockLen){for(let l=1;l<blockCount;l++){var t=l-1;let r=t;for(let a=l;a<blockCount;a++){var e=this.grailComp.compare(array[start+r*blockLen],array[start+a*blockLen]);(0<e||0==e&&0<this.grailComp.compare(array[keys+r],array[keys+a]))&&(r=a)}r!=t&&(this.grailBlockSwap(array,start+t*blockLen,start+r*blockLen,blockLen),this.grailSwap(array,keys+t,keys+r),medianKey==t?medianKey=r:medianKey==r&&(medianKey=t))}return medianKey}grailInPlaceBufferReset(array,start,resetLen,bufferLen){for(let r=start+resetLen-1;r>=start;r--)this.grailSwap(array,r,r-bufferLen)}grailOutOfPlaceBufferReset(array,start,resetLen,bufferLen){for(let r=start+resetLen-1;r>=start;r--)array[r]=array[r-bufferLen]}grailInPlaceBufferRewind(array,start,leftOvers,buffer){for(;start<leftOvers;)this.grailSwap(array,--buffer,--leftOvers)}grailOutOfPlaceBufferRewind(array,start,leftOvers,buffer){for(;start<leftOvers;)array[--buffer]=array[--leftOvers]}grailGetSubarray(array,currentKey,medianKey){return this.grailComp.compare(array[currentKey],array[medianKey])<0?Subarray.LEFT:Subarray.RIGHT}grailCountFinalLeftBlocks(array,offset,blockCount,blockLen){let r=0;var a=offset+blockCount*blockLen;let t=a-blockLen;for(;r<blockCount&&this.grailComp.compare(array[a],array[t])<0;)r++,t-=blockLen;return r}grailSmartMerge(array,start,leftLen,leftOrigin,rightLen,bufferOffset){let r=start;var a=start+leftLen;let t=a;var e=a+rightLen;let l=start-bufferOffset;if(leftOrigin==Subarray.LEFT)for(;r<a&&t<e;)this.grailComp.compare(array[r],array[t])<=0?(this.grailSwap(array,l,r),r++):(this.grailSwap(array,l,t),t++),l++;else for(;r<a&&t<e;)this.grailComp.compare(array[r],array[t])<0?(this.grailSwap(array,l,r),r++):(this.grailSwap(array,l,t),t++),l++;r<a?(this.currentBlockLen=a-r,this.grailInPlaceBufferRewind(array,r,a,e)):(this.currentBlockLen=e-t,leftOrigin==Subarray.LEFT?this.currentBlockOrigin=Subarray.RIGHT:this.currentBlockOrigin=Subarray.LEFT)}grailSmartLazyMerge(array,start,leftLen,leftOrigin,rightLen){if(leftOrigin==Subarray.LEFT){if(0<this.grailComp.compare(array[start+leftLen-1],array[start+leftLen]))for(;0!=leftLen;){var r=this.grailBinarySearchLeft(array,start+leftLen,rightLen,array[start]);if(0!=r&&(this.grailRotate(array,start,leftLen,r),start+=r,rightLen-=r),0==rightLen)return void(this.currentBlockLen=leftLen);for(;start++,0!=--leftLen&&this.grailComp.compare(array[start],array[start+leftLen])<=0;);}}else if(0<=this.grailComp.compare(array[start+leftLen-1],array[start+leftLen]))for(;0!=leftLen;){var a=this.grailBinarySearchRight(array,start+leftLen,rightLen,array[start]);if(0!=a&&(this.grailRotate(array,start,leftLen,a),start+=a,rightLen-=a),0==rightLen)return void(this.currentBlockLen=leftLen);for(;start++,0!=--leftLen&&this.grailComp.compare(array[start],array[start+leftLen])<0;);}this.currentBlockLen=rightLen,leftOrigin==Subarray.LEFT?this.currentBlockOrigin=Subarray.RIGHT:this.currentBlockOrigin=Subarray.LEFT}grailSmartMergeOutOfPlace(array,start,leftLen,leftOrigin,rightLen,bufferOffset){let r=start;var a=start+leftLen;let t=a;var e=a+rightLen;let l=start-bufferOffset;if(leftOrigin==Subarray.LEFT)for(;r<a&&t<e;)this.grailComp.compare(array[r],array[t])<=0?(array[l]=array[r],r++):(array[l]=array[t],t++),l++;else for(;r<a&&t<e;)this.grailComp.compare(array[r],array[t])<0?(array[l]=array[r],r++):(array[l]=array[t],t++),l++;r<a?(this.currentBlockLen=a-r,this.grailOutOfPlaceBufferRewind(array,r,a,e)):(this.currentBlockLen=e-t,leftOrigin==Subarray.LEFT?this.currentBlockOrigin=Subarray.RIGHT:this.currentBlockOrigin=Subarray.LEFT)}grailMergeBlocks(array,keys,medianKey,start,blockCount,blockLen,finalLeftBlocks,finalLen){let r,a=blockLen;this.currentBlockLen=blockLen,this.currentBlockOrigin=this.grailGetSubarray(array,keys,medianKey);for(let t=1;t<blockCount;t++,a+=blockLen)r=a-this.currentBlockLen,this.grailGetSubarray(array,keys+t,medianKey)==this.currentBlockOrigin?(this.grailBlockSwap(array,start+r-blockLen,start+r,this.currentBlockLen),r=a,this.currentBlockLen=blockLen):this.grailSmartMerge(array,start+r,this.currentBlockLen,this.currentBlockOrigin,blockLen,blockLen);r=a-this.currentBlockLen,0!=finalLen?(this.currentBlockOrigin==Subarray.RIGHT?(this.grailBlockSwap(array,start+r-blockLen,start+r,this.currentBlockLen),r=a,this.currentBlockLen=blockLen*finalLeftBlocks,this.currentBlockOrigin=Subarray.LEFT):this.currentBlockLen+=blockLen*finalLeftBlocks,this.grailMergeForwards(array,start+r,this.currentBlockLen,finalLen,blockLen)):this.grailBlockSwap(array,start+r,start+r-blockLen,this.currentBlockLen)}grailLazyMergeBlocks(array,keys,medianKey,start,blockCount,blockLen,finalLeftBlocks,finalLen){let r,a=blockLen;this.currentBlockLen=blockLen,this.currentBlockOrigin=this.grailGetSubarray(array,keys,medianKey);for(let t=1;t<blockCount;t++,a+=blockLen)r=a-this.currentBlockLen,this.grailGetSubarray(array,keys+t,medianKey)==this.currentBlockOrigin?(r=a,this.currentBlockLen=blockLen):0!=blockLen&&0!=this.currentBlockLen&&this.grailSmartLazyMerge(array,start+r,this.currentBlockLen,this.currentBlockOrigin,blockLen);r=a-this.currentBlockLen,0!=finalLen&&(this.currentBlockOrigin==Subarray.RIGHT?(r=a,this.currentBlockLen=blockLen*finalLeftBlocks,this.currentBlockOrigin=Subarray.LEFT):this.currentBlockLen+=blockLen*finalLeftBlocks,this.grailLazyMerge(array,start+r,this.currentBlockLen,finalLen))}grailMergeBlocksOutOfPlace(array,keys,medianKey,start,blockCount,blockLen,finalLeftBlocks,finalLen){let r,a=blockLen;this.currentBlockLen=blockLen,this.currentBlockOrigin=this.grailGetSubarray(array,keys,medianKey);for(let t=1;t<blockCount;t++,a+=blockLen)r=a-this.currentBlockLen,this.grailGetSubarray(array,keys+t,medianKey)==this.currentBlockOrigin?(this.arraycopy(array,start+r,array,start+r-blockLen,this.currentBlockLen),r=a,this.currentBlockLen=blockLen):this.grailSmartMergeOutOfPlace(array,start+r,this.currentBlockLen,this.currentBlockOrigin,blockLen,blockLen);r=a-this.currentBlockLen,0!=finalLen?(this.currentBlockOrigin==Subarray.RIGHT?(this.arraycopy(array,start+r,array,start+r-blockLen,this.currentBlockLen),r=a,this.currentBlockLen=blockLen*finalLeftBlocks,this.currentBlockOrigin=Subarray.LEFT):this.currentBlockLen+=blockLen*finalLeftBlocks,this.grailMergeOutOfPlace(array,start+r,this.currentBlockLen,finalLen,blockLen)):this.arraycopy(array,start+r,array,start+r-blockLen,this.currentBlockLen)}grailCombineInPlace(array,keys,start,length,subarrayLen,blockLen,mergeCount,lastSubarray,buffer){for(let o=0;o<mergeCount;o++){var r=start+o*(2*subarrayLen),a=parseInt(2*subarrayLen/blockLen),t=(this.grailInsertSort(array,keys,a),parseInt(subarrayLen/blockLen)),t=this.grailBlockSelectSort(array,keys,r,t,a,blockLen);buffer?this.grailMergeBlocks(array,keys,keys+t,r,a,blockLen,0,0):this.grailLazyMergeBlocks(array,keys,keys+t,r,a,blockLen,0,0)}if(0!=lastSubarray){var e=start+mergeCount*(2*subarrayLen),l=parseInt(lastSubarray/blockLen),i=(this.grailInsertSort(array,keys,l+1),parseInt(subarrayLen/blockLen)),i=this.grailBlockSelectSort(array,keys,e,i,l,blockLen),s=lastSubarray%blockLen;let r;var n,l=l-(r=0!=s?this.grailCountFinalLeftBlocks(array,e,l,blockLen):0);0==l?(n=r*blockLen,buffer?this.grailMergeForwards(array,e,n,s,blockLen):this.grailLazyMerge(array,e,n,s)):buffer?this.grailMergeBlocks(array,keys,keys+i,e,l,blockLen,r,s):this.grailLazyMergeBlocks(array,keys,keys+i,e,l,blockLen,r,s)}buffer&&this.grailInPlaceBufferReset(array,start,length,blockLen)}grailCombineOutOfPlace(array,keys,start,length,subarrayLen,blockLen,mergeCount,lastSubarray){this.arraycopy(array,start-blockLen,this.externalBuffer,0,blockLen);for(let o=0;o<mergeCount;o++){var r=start+o*(2*subarrayLen),a=parseInt(2*subarrayLen/blockLen),t=(this.grailInsertSort(array,keys,a),parseInt(subarrayLen/blockLen)),t=this.grailBlockSelectSort(array,keys,r,t,a,blockLen);this.grailMergeBlocksOutOfPlace(array,keys,keys+t,r,a,blockLen,0,0)}if(0!=lastSubarray){var e=start+mergeCount*(2*subarrayLen),l=parseInt(lastSubarray/blockLen),i=(this.grailInsertSort(array,keys,l+1),subarrayLen/blockLen),i=this.grailBlockSelectSort(array,keys,e,i,l,blockLen),s=lastSubarray%blockLen;let r;var n,l=l-(r=0!=s?this.grailCountFinalLeftBlocks(array,e,l,blockLen):0);0==l?(n=r*blockLen,this.grailMergeOutOfPlace(array,e,n,s,blockLen)):this.grailMergeBlocksOutOfPlace(array,keys,keys+i,e,l,blockLen,r,s)}this.grailOutOfPlaceBufferReset(array,start,length,blockLen),this.arraycopy(this.externalBuffer,0,array,start-blockLen,blockLen)}grailCombineBlocks(array,keys,start,length,subarrayLen,blockLen,buffer){var r=parseInt(length/(2*subarrayLen));let a=parseInt(length%(2*subarrayLen));a<=subarrayLen&&(length-=a,a=0),buffer&&blockLen<=this.externalBufferLen?this.grailCombineOutOfPlace(array,keys,start,length,subarrayLen,blockLen,r,a):this.grailCombineInPlace(array,keys,start,length,subarrayLen,blockLen,r,a,buffer)}grailLazyMerge(array,start,leftLen,rightLen){if(leftLen<rightLen)for(;0!=leftLen;){var r=this.grailBinarySearchLeft(array,start+leftLen,rightLen,array[start]);if(0!=r&&(this.grailRotate(array,start,leftLen,r),start+=r,rightLen-=r),0==rightLen)break;for(;start++,0!=--leftLen&&this.grailComp.compare(array[start],array[start+leftLen])<=0;);}else{let r=start+leftLen+rightLen-1;for(;0!=rightLen;){var a=this.grailBinarySearchRight(array,start,leftLen,array[r]);if(a!=leftLen&&(this.grailRotate(array,start+a,leftLen-a,rightLen),r-=leftLen-a,leftLen=a),0==leftLen)break;for(var t=start+leftLen-1;rightLen--,r--,0!=rightLen&&this.grailComp.compare(array[t],array[r])<=0;);}}}grailLazyStableSort(array,start,length){for(let l=1;l<length;l+=2){var r=start+l-1,a=start+l;0<this.grailComp.compare(array[r],array[a])&&this.grailSwap(array,r,a)}for(let i=2;i<length;i*=2){let r;var t=length-2*i;for(r=0;r<=t;r+=2*i)this.grailLazyMerge(array,start+r,i,i);var e=length-r;e>i&&this.grailLazyMerge(array,start+r,i,e-i)}}static calcMinKeys(numKeys,blockKeysSum){let r=1;for(;r<numKeys&&0!=blockKeysSum;)r*=2,blockKeysSum=parseInt(blockKeysSum/8);return r}*grailCommonSort(array,start,length,extBuf,extBufLen){if(length<16)yield*this.grailInsertSort(array,start,length);else{let t=1;for(;t*t<length;)t*=2;let e=parseInt((length-1)/t)+1;var r=e+t,s=yield*this.grailCollectKeys(array,start,length,r);let l;if(s<r){if(s<4)return void(yield*this.grailLazyStableSort(array,start,length));for(e=t,t=0,l=!1;e>s;)e=parseInt(e/2)}else l=!0;var n,o=t+e;let i;for(i=l?t:e,l&&null!=extBuf&&(this.externalBuffer=extBuf,this.externalBufferLen=extBufLen),yield*this.grailBuildBlocks(array,start+o,length-o,i);length-o>2*i;){i*=2;let r=t,a=l;a||(4<e&&parseInt(e/8)*e>=i?(r=parseInt(e/2),a=!0):(n=parseInt(i*s)/2,n=GrailSort.calcMinKeys(e,n),r=parseInt(2*i)/n)),this.grailCombineBlocks(array,start,start+o,length-o,i,r,a)}yield*this.grailInsertSort(array,start,o),yield*this.grailLazyMerge(array,start,o,length-o)}}*grailSortInPlace(array,start,length){yield*this.grailCommonSort(array,start,length,null,0)}}export{GrailSort};