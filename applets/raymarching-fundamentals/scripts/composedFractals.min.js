import{extrudedCubeDE,kIFSCubeDE,mandelbulbDE,mengerSpongeDE,qJuliaDE}from"./distanceEstimators.min.js";import{getRotationMatrix,RaymarchApplet}from"/scripts/applets/raymarchApplet.min.js";class ComposedFractals extends RaymarchApplet{sphereWeight=0;extrudedCubeWeight=1;extrudedCubeSeparation=1.5;mengerSpongeWeight=0;mengerSpongeScale=3;includeRotationMatrix=!1;constructor({canvas,useShadows=!1,useReflections=!1,includeSphere=!1,includeExtrudedCube=!1,includeMengerSponge=!1,includeKIFS=!1,includeMandelbulb=!1,includeQJulia=!1}){var e=includeMengerSponge||includeKIFS||includeMandelbulb||includeQJulia;super({canvas:canvas,distanceEstimatorGlsl:`
			float distanceGround = distanceEstimatorGround(pos);
			float distanceObject = distanceEstimatorObject(pos);

			return min(distanceGround, distanceObject);
		`,getColorGlsl:`
			float distanceGround = distanceEstimatorGround(pos);
			float distanceObject = distanceEstimatorObject(pos);

			float minDistance = min(distanceGround, distanceObject);

			if (minDistance == distanceGround)
			{
				vec2 co = floor(pos.xy * 50.0);
				return vec3(0.5, 0.5, 0.5)
					* (1.0 + .2 * (rand(co) - .5));
			}

			if (minDistance == distanceObject)
			{
				return getColorObject(pos);
			}
		`,getReflectivityGlsl:`
			float distanceGround = distanceEstimatorGround(pos);
			float distanceObject = distanceEstimatorObject(pos);

			float minDistance = min(distanceGround, distanceObject);

			if (minDistance == distanceGround)
			{
				return .05;
			}

			if (minDistance == distanceObject)
			{
				return 0.15;
			}
		`,addGlsl:`
			const vec3 color1 = vec3(1.0, 0.0, 0.0);
			const vec3 color2 = vec3(0.0, 1.0, 0.0);
			const vec3 color3 = vec3(0.0, 0.0, 1.0);

			const vec3 n1Tetrahedron = vec3(-.577350, 0, .816496);
			const vec3 n2Tetrahedron = vec3(.288675, -.5, .816496);
			const vec3 n3Tetrahedron = vec3(.288675, .5, .816496);
			const vec3 scaleCenterTetrahedron = vec3(0.0, 0.0, 1.0);

			float rand(vec2 co)
			{
				co += vec2(${Math.random()}, ${Math.random()});

				return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);
			}

			vec4 qmul(vec4 z, vec4 w)
			{
				return vec4(z.x*w.x - z.y*w.y - z.z*w.z - z.w*w.w, z.x*w.y + z.y*w.x + z.z*w.w - z.w*w.z, z.x*w.z - z.y*w.w + z.z*w.x + z.w*w.y, z.x*w.w + z.y*w.z - z.z*w.y + z.w*w.x);
			}

			${includeSphere?`
				float distanceEstimatorRoomSphere(vec3 pos)
				{
					vec3 modPos = mod(pos, 2.0);
					return 1.25 - length(modPos - vec3(1.0, 1.0, 1.0));
				}

				vec3 getColorRoomSphere(vec3 pos)
				{
					return vec3(0.5, 0.0, 1.0);
				}
			`:""}

			${includeExtrudedCube?`
				${extrudedCubeDE[0]}
				${extrudedCubeDE[1]}
			`:""}

			${includeMengerSponge?`
				${mengerSpongeDE[0]}
				${mengerSpongeDE[1]}
			`:""}

			${includeKIFS?`
				${kIFSCubeDE[0]}
				${kIFSCubeDE[1]}
			`:""}

			${includeMandelbulb?`
				${mandelbulbDE[0]}
				${mandelbulbDE[1]}
			`:""}

			${includeQJulia?`
				${qJuliaDE[0]}
				${qJuliaDE[1]}
			`:""}

			float distanceEstimatorGround(vec3 pos)
			{
				return abs(pos.z);
			}

			float distanceEstimatorObject(vec3 pos)
			{
				float distanceObject = 0.0;

				float c = cos(objectRotation);
				float s = sin(objectRotation);
				vec3 rotatedPos = mat3(c, s, 0.0, -s, c, 0.0, 0.0, 0.0, 1.0) * (pos + vec3(0.0, 0.0, objectFloat));
				
				${includeSphere?`
					if (sphereWeight > 0.0)
					{
						distanceObject += sphereWeight * distanceEstimatorRoomSphere(pos);
					}
				`:""}

				${includeExtrudedCube?`
					if (extrudedCubeWeight > 0.0)
					{
						distanceObject += extrudedCubeWeight * distanceEstimatorExtrudedCube(rotatedPos);
					}
				`:""}

				${includeMengerSponge?`
					if (mengerSpongeWeight > 0.0)
					{
						distanceObject += mengerSpongeWeight * distanceEstimatorMengerSponge(rotatedPos);
					}
				`:""}

				${includeKIFS?`
					if (kIFSWeight > 0.0)
					{
						distanceObject += kIFSWeight * distanceEstimatorKIFS(rotatedPos);
					}
				`:""}

				${includeMandelbulb?`
					if (mandelbulbWeight > 0.0)
					{
						distanceObject += mandelbulbWeight * distanceEstimatorMandelbulb(rotatedPos);
					}
				`:""}

				${includeQJulia?`
					if (qJuliaWeight > 0.0)
					{
						distanceObject += qJuliaWeight * distanceEstimatorQJulia(rotatedPos);
					}
				`:""}
				
				return distanceObject;
			}

			vec3 getColorObject(vec3 pos)
			{
				vec3 color = vec3(0.0, 0.0, 0.0);

				float c = cos(objectRotation);
				float s = sin(objectRotation);
				vec3 rotatedPos = mat3(c, s, 0.0, -s, c, 0.0, 0.0, 0.0, 1.0) * (pos + vec3(0.0, 0.0, objectFloat));

				${includeSphere?`
					if (sphereWeight > 0.0)
					{
						color += sphereWeight * getColorRoomSphere(pos);
					}
				`:""}

				${includeExtrudedCube?`
					if (extrudedCubeWeight > 0.0)
					{
						color += extrudedCubeWeight * getColorExtrudedCube(rotatedPos);
					}
				`:""}

				${includeMengerSponge?`
					if (mengerSpongeWeight > 0.0)
					{
						color += mengerSpongeWeight * getColorMengerSponge(rotatedPos);
					}
				`:""}

				${includeKIFS?`
					if (kIFSWeight > 0.0)
					{
						color += kIFSWeight * getColorKIFS(rotatedPos);
					}
				`:""}

				${includeMandelbulb?`
					if (mandelbulbWeight > 0.0)
					{
						color += mandelbulbWeight * getColorMandelbulb(rotatedPos);
					}
				`:""}

				${includeQJulia?`
					if (qJuliaWeight > 0.0)
					{
						color += qJuliaWeight * getColorQJulia(rotatedPos);
					}
				`:""}

				return color;
			}
		`,uniformsGlsl:`
			uniform float objectRotation;
			uniform float objectFloat;
			uniform float sphereWeight;
			uniform float extrudedCubeWeight;
			uniform float extrudedCubeSeparation;
			uniform float mengerSpongeWeight;
			uniform float mengerSpongeScale;
			uniform float rotationMatrix;
			uniform float kIFSWeight;
			uniform float mandelbulbWeight;
			uniform float qJuliaWeight;
		`,uniforms:{objectRotation:0,objectFloat:0,...includeSphere?{sphereWeight:1}:{},extrudedCubeWeight:0,extrudedCubeSeparation:1.5,...includeMengerSponge?{mengerSpongeWeight:1,mengerSpongeScale:3}:{},...e?{rotationMatrix:[[1,0,0],[0,1,0],[0,0,1]]}:{},...includeKIFS?{kIFSWeight:0}:{},...includeMandelbulb?{mandelbulbWeight:0}:{},...includeQJulia?{qJuliaWeight:0}:{}},maxMarches:192,cameraPos:[1,1,1],theta:1.25*Math.PI,phi:2.1539,lockedOnOrigin:!1,lockZ:1,fogColor:[.6,.73,.87],fogScaling:.075,epsilonScaling:.9,useShadows:useShadows,useReflections:useReflections}),this.includeRotationMatrix=e,this.wilson.setUniforms({aspectRatio:[Math.max(1,this.wilson.canvasWidth/this.wilson.canvasHeight),Math.max(1,1/this.wilson.canvasWidth/this.wilson.canvasHeight)]})}distanceEstimator(){return 1}updateRotationAndFloat(){this.setUniforms({objectRotation:this.uniforms.objectRotation+.003,objectFloat:.1*Math.sin(3*this.uniforms.objectRotation),...this.includeRotationMatrix?{rotationMatrix:getRotationMatrix((Math.sin(3*this.uniforms.objectRotation+1.013)+1)/6,(Math.sin(2*this.uniforms.objectRotation)+1)/6,(Math.sin(5*this.uniforms.objectRotation+.53)+1)/6)}:{}}),this.needNewFrame=!0}prepareFrame(timeElapsed){this.moveUpdate(timeElapsed),this.updateRotationAndFloat()}}export{ComposedFractals};