import{Applet,getMinGlslString,getVectorGlsl,hsvToRgb,tempShader}from"../../../scripts/applets/applet.min.js";import anime from"/scripts/anime.min.js";import{WilsonGPU}from"/scripts/wilson.min.js";class VoronoiDiagrams extends Applet{wilsonHidden;anime;lastTimestamp=-1;currentlyAnimating=!1;numPoints=20;metric=2;resolution=1e3;resolutionHidden=100;maximumSpeed;drawPoints;useDraggable;t;radius;maxRadius;pointRadius;pointOpacity;points;colors;cancelAnimaton=()=>{};constructor({canvas}){super(canvas);var i={shader:tempShader,canvasWidth:this.resolution,draggableOptions:{draggables:{point0:[0,0]},callbacks:{drag:this.onDragDraggable.bind(this)}},fullscreenOptions:{onSwitch:this.switchFullscreen.bind(this),beforeSwitch:this.beforeSwitchFullscreen.bind(this),useFullscreenButton:!0,enterFullscreenButtonIconPath:"/graphics/general-icons/enter-fullscreen.png",exitFullscreenButtonIconPath:"/graphics/general-icons/exit-fullscreen.png"}},i=(this.wilson=new WilsonGPU(this.canvas,i),this.wilson.draggables.point0.element.style.display="none",{shader:tempShader,canvasWidth:this.resolutionHidden});this.wilsonHidden=new WilsonGPU(this.createHiddenCanvas(),i)}run({resolution=500,numPoints=20,metric=2,maximumSpeed=!1,drawPoints=!1,useDraggable=!1}){this.resolution=resolution,this.numPoints=numPoints,this.metric=metric,this.maximumSpeed=maximumSpeed,this.drawPoints=drawPoints,this.useDraggable=useDraggable,this.t=-.1,this.radius=-.1,this.pointOpacity=1,this.lastTimestamp=-1,this.wilson.resizeCanvas({width:this.resolution}),this.generatePoints(),this.wilsonHidden.loadShader({source:this.getShader(!0),uniforms:{radius:this.radius,metric:this.metric,...this.useDraggable?{point0:this.wilson.draggables.point0.location}:{}}}),this.maximumSpeed?this.maxRadius=8:this.maxRadius=this.findMaxRadius(),this.wilson.loadShader({source:this.getShader(!1),uniforms:{radius:this.radius,pointOpacity:this.pointOpacity,metric:this.metric,...this.useDraggable?{point0:this.wilson.draggables.point0.location}:{}}}),this.wilson.draggables.point0.element.style.display=this.useDraggable?"block":"none";const i={t:-.3,pointOpacity:1};let t=!(this.currentlyAnimating=!0);this.cancelAnimaton(),this.cancelAnimaton=()=>{this.currentlyAnimating=!1,t=!0},this.maximumSpeed?(this.t=1,this.pointOpacity=this.drawPoints?1:0,this.drawFrame(),this.currentlyAnimating=!1):this.anime=anime({targets:i,t:1,pointOpacity:this.drawPoints?1:-.5,duration:3e3,delay:2*this.numPoints,easing:"easeOutQuad",update:()=>{t||(this.t=i.t,this.pointOpacity=Math.max(i.pointOpacity,0),this.drawFrame())},complete:()=>{t||(this.anime=null,this.currentlyAnimating=!1)}})}getShader(forHiddenCanvas=!1){var i=forHiddenCanvas?`
				if (minDistance < radius)
				{
					gl_FragColor = vec4(color, 1);
					return;
				}
			`:`
				if (minDistance < pointRadius)
				{
					gl_FragColor = mix(
						vec4(color, 1),
						vec4(1, 1, 1, 1),
						pointOpacity
					);
					return;
				}

				if (minDistance < (1.0 + blurRatio) * pointRadius)
				{
					float t = 1.0 - (minDistance - pointRadius) / (blurRatio * pointRadius);

					gl_FragColor = mix(
						vec4(color, 1),
						vec4(t, t, t, 1),
						pointOpacity
					);
					return;
				}

				if (minDistance < radius)
				{
					float boundaryDistance = secondMinDistance - minDistance;

					if (boundaryDistance < boundaryWidth / 2.0)
					{
						// Despite all our best efforts, we can still sometimes get here mistakenly.
						// We sample 8 nearby points to make sure this is actually a boundary.
						vec3 newColor;

	${["boundaryWidth / 4.0, 0","-boundaryWidth / 4.0, 0","0, boundaryWidth / 4.0","0, -boundaryWidth / 4.0","boundaryWidth / 4.0, boundaryWidth / 4.0","boundaryWidth / 4.0, -boundaryWidth / 4.0","-boundaryWidth / 4.0, boundaryWidth / 4.0","-boundaryWidth / 4.0, -boundaryWidth / 4.0"].map(testDirection=>`
			getMinDistanceToPoints(uv + vec2(${testDirection}), minDistance, secondMinDistance, newColor);

			if (color != newColor)
			{
				float t = .5 + .5 * boundaryDistance / (boundaryWidth / 2.0);
				gl_FragColor = vec4(color * t, 1);
				return;
			}
		`).join("")}
					}
					
					gl_FragColor = vec4(color, 1);
					return;
				}

				if (minDistance < radius + 0.01)
				{
					gl_FragColor = vec4(color * 0.5, 1);
					return;
				}
			`;return`
			precision highp float;
			
			varying vec2 uv;

			uniform float radius;
			uniform float pointOpacity;
			uniform float metric;

			const float pointRadius = 0.01;
			const float blurRatio = 0.5;
			const float boundaryWidth = 0.02;

	${this.points.map((point,index)=>0===index&&this.useDraggable?`
				uniform vec2 point0;
			`:`
			const vec2 point${index} = ${getVectorGlsl(point)};
		`).join("")}

	${this.colors.map((color,index)=>`
			const vec3 color${index} = ${getVectorGlsl(color)};
		`).join("")}
			
			float metricDistance(vec2 p, vec2 q)
			{
				return pow(
					pow(abs(p.x - q.x), metric)
					+ pow(abs(p.y - q.y), metric),
					1.0 / metric
				);
			}

			void getMinDistanceToPoints(vec2 p, out float minDistance, out float secondMinDistance, out vec3 color)
			{
	${this.points.map((point,index)=>`
			float distance${index+1} = metricDistance(p, point${index});
		`).join("")}

				minDistance = ${getMinGlslString("distance",this.numPoints)};

	${this.colors.map((color,index)=>`
			${index?"else if":"if"} (minDistance == distance${index+1})
			{
				color = color${index};
			}
		`).join("")}

	secondMinDistance = 10.0;

	${this.points.map((point,index)=>`
			if (distance${index+1} < secondMinDistance && distance${index+1} != minDistance)
			{
				secondMinDistance = distance${index+1};
			}
		`).join("")}
			}

			void main(void)
			{
				vec3 color;
				float minDistance;
				float secondMinDistance;
				getMinDistanceToPoints(uv, minDistance, secondMinDistance, color);

				${i}

				gl_FragColor = vec4(0, 0, 0, 1);
			}
		`}generatePoints(){this.points=new Array(this.numPoints);for(let a=0;a<this.numPoints;a++)this.points[a]=[.9*(Math.random()-.5)*this.wilson.worldWidth,.9*(Math.random()-.5)*this.wilson.worldHeight];var t,s=new Array(this.numPoints),i=.2/this.numPoints;for(let r=0;r<this.numPoints;r++){s[r]=[0,0];for(let i=0;i<this.numPoints;i++)i!==r&&(t=(this.points[i][0]-this.points[r][0])**2+(this.points[i][1]-this.points[r][1])**2,s[r][0]+=(this.points[r][0]-this.points[i][0])/t,s[r][1]+=(this.points[r][1]-this.points[i][1])/t)}for(let l=0;l<this.numPoints;l++)this.points[l][0]+=i*s[l][0],this.points[l][1]+=i*s[l][1];for(let h=0;h<2;h++){var n,o,e=h%2?1:-1;for(let t=0;t<this.numPoints;t++)for(let i=0;i<this.numPoints;i++)i!==t&&(n=Math.abs(this.points[t][0]-this.points[i][0]),o=Math.abs(this.points[t][1]-this.points[i][1]),n<.01&&(this.points[t][0]+=.01*e),o<.01&&(this.points[t][1]+=.01*e),Math.abs(n-o)<.01)&&(this.points[t][0]+=.02*e)}for(let c=0;c<this.numPoints;c++)this.points[c][0]=Math.min(Math.max(this.points[c][0],-this.wilson.worldWidth/2),this.wilson.worldWidth/2),this.points[c][1]=Math.min(Math.max(this.points[c][1],-this.wilson.worldHeight/2),this.wilson.worldHeight/2);this.colors=new Array(this.numPoints);for(let d=0;d<this.numPoints;d++)this.colors[d]=hsvToRgb(Math.random(),.5+.25*Math.random(),.5+.5*Math.random()),this.colors[d][0]/=255,this.colors[d][1]/=255,this.colors[d][2]/=255}findMaxRadius(){let i=.5;let t=.25;for(let n=0;n<15;n++){var s=4*i;this.testRadius(s)?14!==n&&(i-=t):i+=t,t/=2}return 4*i+.025}testRadius(radius){this.wilsonHidden.setUniforms({radius:radius}),this.wilsonHidden.drawFrame();var i=this.wilsonHidden.readPixels();for(let t=0;t<i.length;t+=4)if(0===i[t]&&0===i[t+1]&&0===i[t+2])return!1;return!0}drawFrame(){this.radius=this.t*this.maxRadius,this.wilson.setUniforms({radius:this.radius,pointOpacity:this.pointOpacity}),this.wilson.drawFrame()}updateMetric(){this.cancelAnimaton(),this.t=2,this.wilson.setUniforms({metric:this.metric}),this.drawFrame()}onDragDraggable({x,y}){this.wilson.setUniforms({point0:[x,y]}),this.currentlyAnimating||this.drawFrame()}switchFullscreen(){this.anime?.play&&this.anime.play()}async beforeSwitchFullscreen(){this.anime?.pause&&this.anime.pause(),await new Promise(resolve=>setTimeout(resolve,33))}}export{VoronoiDiagrams};