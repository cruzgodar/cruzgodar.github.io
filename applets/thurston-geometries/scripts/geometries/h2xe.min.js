import{getMatrixGlsl,getMinGlslString,getVectorGlsl}from"../../../../scripts/applets/applet.min.js";import{ThurstonGeometry}from"../class.min.js";import{BaseGeometry}from"./base.min.js";const teleportations=[[[1,0,1/Math.sqrt(3),0],[[2,0,Math.sqrt(3),0],[0,1,0,0],[Math.sqrt(3),0,2,0],[0,0,0,1]]],[[-1,0,1/Math.sqrt(3),0],[[2,0,-Math.sqrt(3),0],[0,1,0,0],[-Math.sqrt(3),0,2,0],[0,0,0,1]]],[[0,1,1/Math.sqrt(3),0],[[1,0,0,0],[0,2,Math.sqrt(3),0],[0,Math.sqrt(3),2,0],[0,0,0,1]]],[[0,-1,1/Math.sqrt(3),0],[[1,0,0,0],[0,2,-Math.sqrt(3),0],[0,-Math.sqrt(3),2,0],[0,0,0,1]]]];class H2xEGeometry extends BaseGeometry{geodesicGlsl=`
		float h2Mag = sqrt(abs(
			rayDirectionVec.x * rayDirectionVec.x
			+ rayDirectionVec.y * rayDirectionVec.y
			- rayDirectionVec.z * rayDirectionVec.z
		));
		
		vec4 pos = vec4(
			cosh(h2Mag * t) * startPos.xyz + sinh(h2Mag * t) * rayDirectionVec.xyz / h2Mag,
			startPos.w + t * rayDirectionVec.w
		);
		
		globalColor += teleportPos(pos, startPos, rayDirectionVec, t, totalT);
	`;dotProductGlsl=`
		return v.x * w.x + v.y * w.y - v.z * w.z + v.w * w.w;
	`;normalizeGlsl=`
		return dir * inversesqrt(abs(geometryDot(dir, dir)));
	`;fogGlsl=`
		return mix(color, fogColor, 1.0 - exp(-totalT * 0.25));
	`;functionGlsl=`
		float sinh(float x)
		{
			return .5 * (exp(x) - exp(-x));
		}

		float cosh(float x)
		{
			return .5 * (exp(x) + exp(-x));
		}

		float asinh(float x)
		{
			return log(x + sqrt(x*x + 1.0));
		}

		float acosh(float x)
		{
			return log(x + sqrt(x*x - 1.0));
		}

		const vec4 teleportVec1 = ${getVectorGlsl(teleportations[0][0])};
		const mat4 teleportMat1 = ${getMatrixGlsl(teleportations[0][1])};

		const vec4 teleportVec2 = ${getVectorGlsl(teleportations[1][0])};
		const mat4 teleportMat2 = ${getMatrixGlsl(teleportations[1][1])};

		const vec4 teleportVec3 = ${getVectorGlsl(teleportations[2][0])};
		const mat4 teleportMat3 = ${getMatrixGlsl(teleportations[2][1])};

		const vec4 teleportVec4 = ${getVectorGlsl(teleportations[3][0])};
		const mat4 teleportMat4 = ${getMatrixGlsl(teleportations[3][1])};

		vec3 teleportPos(inout vec4 pos, inout vec4 startPos, inout vec4 rayDirectionVec, inout float t, inout float totalT)
		{
			if (dot(pos, teleportVec1) < 0.0)
			{
				pos = teleportMat1 * pos;

				// !!!IMPORTANT!!! rayDirectionVec is the tangent vector from the *starting*
				// position, not the current one, so we need to calculate that current
				// position to teleport the vector correctly. The correct tangent vector
				// is just the derivative of the geodesic at the current value of t.

				float h2Mag = sqrt(abs(
					rayDirectionVec.x * rayDirectionVec.x
					+ rayDirectionVec.y * rayDirectionVec.y
					- rayDirectionVec.z * rayDirectionVec.z
				));

				rayDirectionVec = teleportMat1 * vec4(
					h2Mag * sinh(h2Mag * t) * startPos.xyz + cosh(h2Mag * t) * rayDirectionVec.xyz,
					rayDirectionVec.w
				);

				startPos = pos;
				
				totalT += t;
				t = 0.0;

				return vec3(0.0, 1.0, 0.0);
			}

			if (dot(pos, teleportVec2) < 0.0)
			{
				pos = teleportMat2 * pos;

				float h2Mag = sqrt(abs(
					rayDirectionVec.x * rayDirectionVec.x
					+ rayDirectionVec.y * rayDirectionVec.y
					- rayDirectionVec.z * rayDirectionVec.z
				));
				
				rayDirectionVec = teleportMat2 * vec4(
					h2Mag * sinh(h2Mag * t) * startPos.xyz + cosh(h2Mag * t) * rayDirectionVec.xyz,
					rayDirectionVec.w
				);

				startPos = pos;
				
				totalT += t;
				t = 0.0;

				return vec3(0.0, -1.0, 0.0);
			}

			if (dot(pos, teleportVec3) < 0.0)
			{
				pos = teleportMat3 * pos;

				float h2Mag = sqrt(abs(
					rayDirectionVec.x * rayDirectionVec.x
					+ rayDirectionVec.y * rayDirectionVec.y
					- rayDirectionVec.z * rayDirectionVec.z
				));
				
				rayDirectionVec = teleportMat3 * vec4(
					h2Mag * sinh(h2Mag * t) * startPos.xyz + cosh(h2Mag * t) * rayDirectionVec.xyz,
					rayDirectionVec.w
				);

				startPos = pos;
				
				totalT += t;
				t = 0.0;

				return vec3(0.0, 0.0, 1.0);
			}

			if (dot(pos, teleportVec4) < 0.0)
			{
				pos = teleportMat4 * pos;

				float h2Mag = sqrt(abs(
					rayDirectionVec.x * rayDirectionVec.x
					+ rayDirectionVec.y * rayDirectionVec.y
					- rayDirectionVec.z * rayDirectionVec.z
				));
				
				rayDirectionVec = teleportMat4 * vec4(
					h2Mag * sinh(h2Mag * t) * startPos.xyz + cosh(h2Mag * t) * rayDirectionVec.xyz,
					rayDirectionVec.w
				);

				startPos = pos;
				
				totalT += t;
				t = 0.0;

				return vec3(0.0, 0.0, -1.0);
			}

			return vec3(0.0, 0.0, 0.0);
		}
	`;maxT="30.0";correctPosition(pos){var t=Math.sqrt(-pos[0]*pos[0]-pos[1]*pos[1]+pos[2]*pos[2]);return[pos[0]/t,pos[1]/t,pos[2]/t,pos[3]]}getNormalVec(cameraPos){return this.normalize([-cameraPos[0],-cameraPos[1],cameraPos[2],0])}dotProduct(vec1,vec2){return vec1[0]*vec2[0]+vec1[1]*vec2[1]-vec1[2]*vec2[2]+vec1[3]*vec2[3]}normalize(vec){var t=Math.sqrt(Math.abs(this.dotProduct(vec,vec)));return[vec[0]/t,vec[1]/t,vec[2]/t,vec[3]/t]}correctVectors(){function t(vec1,vec2){return vec1[0]*vec2[0]+vec1[1]*vec2[1]-vec1[2]*vec2[2]}var e=t(this.cameraPos,this.upVec),o=t(this.cameraPos,this.rightVec),r=t(this.cameraPos,this.forwardVec);for(let s=0;s<3;s++)this.upVec[s]+=e*this.cameraPos[s],this.rightVec[s]+=o*this.cameraPos[s],this.forwardVec[s]+=r*this.cameraPos[s];this.upVec=this.normalize(this.upVec),this.rightVec=this.normalize(this.rightVec),this.forwardVec=this.normalize(this.forwardVec)}baseColorIncreases=[[0,1,0],[0,-1,0],[0,0,1],[0,0,-1]];baseColor=[0,0,0];teleportCamera(rotatedForwardVec,recomputeRotation){for(let t=0;t<teleportations.length;t++)ThurstonGeometry.dotProduct(this.cameraPos,teleportations[t][0])<0&&(this.cameraPos=ThurstonGeometry.mat4TimesVector(teleportations[t][1],this.cameraPos),this.forwardVec=ThurstonGeometry.mat4TimesVector(teleportations[t][1],this.forwardVec),this.rightVec=ThurstonGeometry.mat4TimesVector(teleportations[t][1],this.rightVec),this.upVec=ThurstonGeometry.mat4TimesVector(teleportations[t][1],this.upVec),recomputeRotation(ThurstonGeometry.mat4TimesVector(teleportations[t][1],rotatedForwardVec)),this.baseColor[0]+=this.baseColorIncreases[t][0],this.baseColor[1]+=this.baseColorIncreases[t][1],this.baseColor[2]+=this.baseColorIncreases[t][2])}}class H2xEAxes extends H2xEGeometry{geodesicGlsl=`
		float h2Mag = sqrt(abs(
			rayDirectionVec.x * rayDirectionVec.x
			+ rayDirectionVec.y * rayDirectionVec.y
			- rayDirectionVec.z * rayDirectionVec.z
		));
		
		vec4 pos = vec4(
			cosh(h2Mag * t) * startPos.xyz + sinh(h2Mag * t) * rayDirectionVec.xyz / h2Mag,
			startPos.w + t * rayDirectionVec.w
		);
	`;functionGlsl=`
		float sinh(float x)
		{
			return .5 * (exp(x) - exp(-x));
		}

		float cosh(float x)
		{
			return .5 * (exp(x) + exp(-x));
		}

		float asinh(float x)
		{
			return log(x + sqrt(x*x + 1.0));
		}

		float acosh(float x)
		{
			return log(x + sqrt(x*x - 1.0));
		}
	`;teleportCamera(){}static distances=`
		float distance1 = length(vec2(acosh(sqrt(1.0 + pos.y * pos.y)), pos.w)) - .05;
		float distance2 = length(vec2(acosh(sqrt(1.0 + pos.x * pos.x)), pos.w)) - .05;
		float distance3 = acosh(pos.z) - .05;

		float minDistance = ${getMinGlslString("distance",3)};
	`;distanceEstimatorGlsl=`
		${H2xEAxes.distances}

		return minDistance;
	`;getColorGlsl=`
		${H2xEAxes.distances}

		if (minDistance == distance1)
		{
			return vec3(
				1.0,
				.5 + .25 * (.5 * (sin(20.0 * pos.x) + 1.0)),
				.5 + .25 * (.5 * (cos(20.0 * pos.x) + 1.0))
			);
		}

		if (minDistance == distance2)
		{
			return vec3(
				.5 + .25 * (.5 * (sin(20.0 * pos.y) + 1.0)),
				1.0,
				.5 + .25 * (.5 * (cos(20.0 * pos.y) + 1.0))
			);
		}

		return vec3(
			.5 + .25 * (.5 * (sin(5.0 * pos.w) + 1.0)),
			.5 + .25 * (.5 * (cos(5.0 * pos.w) + 1.0)),
			1.0
		);
	`;lightGlsl=`
		vec4 lightDirection1 = normalize(vec4(-1.0, 1.0, 0.0, .5) - pos);
		float dotProduct1 = abs(dot(surfaceNormal, lightDirection1));

		float lightIntensity = 1.5 * dotProduct1;
	`;cameraPos=[-.52612,.55674,1.25967,.34129];normalVec=[.52619,-.55667,1.25966,0];upVec=[0,0,0,1];rightVec=[.70684,.70758,.01743,0];forwardVec=[.88161,-.89956,-.7658,0];movingSpeed=1.25}class H2xERooms extends H2xEGeometry{static distances=`
		float spacing = 1.875;
		float distance1 = wallThickness - length(vec2(acosh(pos.z), mod(pos.w + spacing / 2.0, spacing) - spacing / 2.0));

		// Translate the reflection plane to the x = 0 plane, then get the distance to it.
		// The DE to x = 0 is abs(asinh(pos.x)).
		float distance2 = abs(asinh(
			dot(
				vec4(1.23188, 0.0, 0.71939, 0),
				pos
			)
		));
		
		float distance3 = abs(asinh(
			dot(
				vec4(1.23188, 0.0, -0.71939, 0),
				pos
			)
		));

		float distance4 = abs(asinh(
			dot(
				vec4(0.0, 1.23188, 0.71939, 0),
				pos
			)
		));
		
		float distance5 = abs(asinh(
			dot(
				vec4(0.0, -1.23188, 0.71939, 0),
				pos
			)
		));

		float minDistance = ${getMinGlslString("distance",5)};
	`;distanceEstimatorGlsl=`
		${H2xERooms.distances}

		return minDistance;
	`;getColorGlsl=`
		${H2xERooms.distances}

		float wColor = floor((pos.w + 3.0 * spacing / 2.0) / spacing) - spacing / 2.0;

		return vec3(
			.15 + .85 * .5 * (sin((.05 * pos.x + wColor + globalColor.y + baseColor.y + globalColor.z + baseColor.z) * 5.0) + 1.0),
			.15 + .85 * .5 * (sin((.05 * pos.y + wColor + globalColor.y + baseColor.y) * 7.0) + 1.0),
			.15 + .85 * .5 * (sin((.05 * pos.z + wColor + globalColor.z + baseColor.z) * 11.0) + 1.0)
		);
	`;lightGlsl=`
		float spacing = 1.875;
		vec4 moddedPos = vec4(pos.xyz, mod(pos.w + spacing / 2.0, spacing) - spacing / 2.0);

		vec4 lightDirection1 = normalize(vec4(-1.0, 1.0, 0.0, .5) - moddedPos);
		float dotProduct1 = abs(dot(surfaceNormal, lightDirection1));

		vec4 lightDirection2 = normalize(vec4(1.0, -1.0, 0.0, -.5) - moddedPos);
		float dotProduct2 = dot(surfaceNormal, lightDirection2);

		

		float lightIntensity = 1.5 * max(dotProduct1, dotProduct2);
	`;cameraPos=[0,.025,Math.sqrt(1.000625),0];normalVec=[0,-.025,Math.sqrt(1.000625),0];upVec=[0,0,0,1];rightVec=[-1,0,0,0];forwardVec=[0,1,0,0];movingSpeed=1.25;uniformGlsl=`
		uniform float wallThickness;
		uniform vec3 baseColor;
	`;uniformNames=["wallThickness","baseColor"];updateUniforms(gl,uniformList){var t=1.145-this.sliderValues.wallThickness/10;gl.uniform1f(uniformList.wallThickness,t),gl.uniform3fv(uniformList.baseColor,this.baseColor)}uiElementsUsed="#wall-thickness-slider";wallThicknessData=[1.55,-.55,1.55]}export{H2xEAxes,H2xERooms};