<header><div id="logo"><a href="/home" tabindex="-1"><img src="/graphics/general-icons/logo.webp" alt="Logo" tabindex="1"></img></a></div><div style="height: 20px"></div><h1 class="heading-text">Lambda Calculus</h1></header><main><section><p class="body-text">One of the most minimal Turing-complete languages, <a href="https://en.wikipedia.org/wiki/Lambda_calculus">lambda calculus</a> is a tiny programming language in which the only objects are functions. The notation <code>λx.E</code> is a function taking the variable <code>x</code> and returning the expression <code>E</code> &mdash; it&#x2019;s equivalent to <code>(x) => E</code> in JavaScript or <code>lambda x: E</code> in Python. Functions can also construct other functions and return them: <code>λx.λy.x</code> is a function that takes <code>x</code> and returns a one-variable constant function that takes in a variable <code>y</code> but just returns <code>x</code>.</p><p class="body-text">Two expressions next to one another represent function application, so <code>λz.zz</code> is a function taking an argument <code>z</code> (which is itself a function) and returning the composition <code>z(z)</code>. If we evaluate a function defined with a lambda constructor directly on another function, as in <code>(λz.zz)(λx.λy.x)</code>, then we can plug the argument <code>(λx.λy.x)</code> in for <code>z</code> in the first lambda to get <code>(λx.λy.x)(λx.λy.x)</code>. Then we can plug the second lambda <code>(λx.λy.x)</code> in for <code>x</code> in the first to finally find <code>λy.λx.λy.x</code>, a function of three variables that returns the second. This evaluation process is called <strong>beta reduction</strong>, and it is the only way to substantively change an expression while preserving its meaning.</p><p class="body-text">While there are a number of ways to visually represent a lambda expression, I find <a href="https://tromp.github.io/cl/diagrams.html">those made by John Tromp</a> to be particularly pleasing. Lambda terms like <code>λx.E</code> are represented by horizontal lines over their body <code>E</code>, and any uses of <code>x</code> within <code>E</code> are represented by vertical lines connecting to that bar. An application of one function to another is given by a horizontal bar connecting the bottom-left corners of the two, with the function on the left and its input on the right.</p><p class="body-text">Without any concept of non-function objects, defining a useful concept of numbers, arithmetic, and logic is not as straightforward as we might like. The standard approach is to represent true and false by the selector functions <code>T = λx.λy.x</code> and <code>F = λx.λy.y</code>, and natural numbers by <code>n = λf.λx.f(...(f(x))...)</code>, where there are <code>n</code> copies of <code>f</code> in the composition. From these building blocks, we can define everything we need, and even extend to recursion, <code>for</code> loops, and more.</p><p class="body-text">I learned about these diagrams from the YouTuber <a href="https://www.youtube.com/@twoswap">2swap</a>, who made an <a href="https://www.youtube.com/watch?v=RcVA8Nj6HEo">excellent video</a> animating the process of beta reduction. I wanted to take on the challenge of animating them myself &mdash; this applet allows for freely entering any lambda expression (just type an <code>L</code> to insert a <code>λ</code>), color-codes the diagrams by assigning colors to <code>λ</code> terms and their bound variables (and also syntax-highlights the expression accordingly), and finally animates the reduction process. It also supports a number of shorthand variables featured in the examples and documented in the guide (the top-left help button). This was a staggeringly complicated applet to write, but I&#x2019;m very happy with the result!</p><div class="text-buttons dropdown-holder"><div class="dropdown-container focus-on-child" tabindex="1"><button class="text-button dropdown" type="button" id="examples-dropdown-button" tabindex="-1"></button><select id="examples-dropdown"></select></div></div><div id="canvas-landscape"><div id="canvas-landscape-left"><div class="checkboxes"><div class="checkbox-row"><div class="checkbox-container" tabindex="1"><input type="checkbox" id="expand-shorthands-checkbox"><div class="checkbox"></div></div><label for="expand-shorthands-checkbox" style="margin-left: 10px"><p class="body-text checkbox-subtext"></p></label></div><div class="checkbox-row"><div class="checkbox-container" tabindex="1"><input type="checkbox" id="update-expression-during-reduction-checkbox"><div class="checkbox"></div></div><label for="update-expression-during-reduction-checkbox" style="margin-left: 10px"><p class="body-text checkbox-subtext"></p></label></div></div><div class="text-field-container"><div class="textarea-wrapper"><textarea cols="16" rows="4" name="expression-textarea" id="expression-textarea" class="text-field" spellcheck="false" autocapitalize="off" autocomplete="off" autocorrect="off"></textarea><div class="textarea-overlay"></div></div><p class="body-text" style="text-align: center"></p></div><div class="text-buttons"><div class="focus-on-child" tabindex="1"><button class="text-button" type="button" id="reduce-button" tabindex="-1"></button></div><div class="focus-on-child" tabindex="1"><button class="text-button" type="button" id="play-pause-button" tabindex="-1"></button></div></div><div class="sliders"><div class="slider-container"><div class="slider-bar"></div><div id="animation-time-slider" class="slider-thumb"></div><p class="body-text slider-subtext"></p></div></div></div><div id="canvas-landscape-middle"><canvas id="output-canvas" class="output-canvas"></canvas></div><div id="canvas-landscape-right"><div class="text-buttons"><div class="focus-on-child" tabindex="1"><button class="text-button" type="button" id="download-button" tabindex="-1"></button></div></div></div></div><div id="applet-controls-card" class="card"><h1 class="heading-text">Controls</h1><p class="body-text">A number of common operations and combinators have shorthands that can optionally be expanded directly (although those expansions tend to get very messy very fast).</p><p class="body-text"><span style="height: 32px"></span></p><p class="body-text"><code>T</code>: the function <code>λx.λy.x</code>, used as the boolean value <code>true</code>.</p><p class="body-text"><code>F</code>: the function <code>λx.λy.y</code>, used as the boolean value <code>false</code>.</p><p class="body-text"><code>!</code>: the boolean negation operator <code>λb.bFT</code>.</p><p class="body-text"><code>&</code>: the boolean and operator <code>λb.λc.bcF</code>.</p><p class="body-text"><code>|</code>: the boolean or operator <code>λb.λc.bTc</code>.</p><p class="body-text"><span style="height: 32px"></span></p><p class="body-text"><code>0-9</code>: A Church numeral.</p><p class="body-text"><code>_</code>: the <code>isZero</code> function <code>λn.n(λx.F)T</code>.</p><p class="body-text"><code>></code>: the increment operator <code>λn.λf.λx.f(nf(x))</code>.</p><p class="body-text"><code>&lt;</code>: the decrement operator <code>λn.λf.λx.n(λg.λh.h(gf))(λu.x)(λu.u)</code> (returns <code>0</code> if <code>n</code> is <code>0</code>).</p><p class="body-text"><code>+</code>: the addition operator <code>λa.λb.λf.λx.(af)(bfx)</code>.</p><p class="body-text"><code>*</code>: the multiplication operator <code>λa.λb.λf.b(af)</code>.</p><p class="body-text"><code>^</code>: the exponentiation operator <code>λa.λb.ba</code>.</p><p class="body-text"><code>-</code>: the subtraction operator <code>λa.λb.a&lt;b</code> (returns <code>0</code> if <code>a < b</code>).</p><p class="body-text"><code>=</code>: the equality operator <code>λa.λb.&(_(-ab))(_(-ba))</code>.</p><p class="body-text"><span style="height: 32px"></span></p><p class="body-text"><code>I</code>: The identity function <code>λx.x</code>.</p><p class="body-text"><code>K</code>: The first-argument function <code>λx.λy.x</code>, also used as the boolean value <code>true</code>.</p><p class="body-text"><code>S</code>: The substitution operator <code>λx.λy.λz.(xz)(yz)</code>.</p><p class="body-text"><code>Y</code>: The Y combinator <code>λf.(λx.f(xx))(λx.f(xx))</code>, used to implement recursion.</p><p class="body-text"><span style="height: 32px"></span></p><p class="body-text"><code>,</code>: The pairing operator <code>λx.λy.λz.zxy</code>. Packs <code>x</code> and <code>y</code> into an ordered pair.</p><p class="body-text"><code>'</code>: The first-entry extractor <code>λp.p(λx.λy.x)</code>. Retrieves the first entry of <code>p</code>.</p><p class="body-text"><code>"</code>: The second-entry extractor <code>λp.p(λx.λy.y)</code>. Retrieves the second entry of <code>p</code>.</p></div></section></main>